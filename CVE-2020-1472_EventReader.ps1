# ---------------------------------
# CVE-2020-1472 이벤트 리더 v1.0 2020 년 9 월 21일
# 이 스크립트는 다음을 수행합니다.
# 	1. 입력 파일 폴더에서 시스템 evtx를 스캔하여 이벤트 5827, 5828,5829,5830 및 5831, 정확한 데이터 필드, 582 #-*. CSV로 내 보냅니다.
# 	2. Excel을 호출하여 결과 582 #-*. CSV를 가져오고 일반적인 보안 RPC 분석 시나리오를위한 피벗 테이블을 만듭니다. 나중에 582 #-*. CSV를 삭제합니다.
#    필요에 맞게 자유롭게 수정하십시오.
# ---------------------------------
# 스크립트에는 Excel 2013 이상이 필요합니다.
#    64 비트 Excel에서는 XLS로 더 큰 데이터 가져 오기를 생성 할 수 있습니다.
# ---------------------------------
# 스크립트를 사용하려면 :
#   1. 시스템 로그를 파일에 system.evtx로 저장합니다.
#   2. 화면 프롬프트에 따라 * .evtx 및 최종 xlsx가 포함 된 경로를 입력합니다.
#
# 추가 정보 https://support.microsoft.com/en-us/kb/4557222


# ---------------------------------------
# 스크립트 전역 / 조정 변수.
# ---------------------------------------
#    -$ mcScriptPrompts> $ false로 설정하면 스크립트는 프롬프트없이 스크립트 파일 폴더의 모든 evtx를 처리합니다. evtx를 삭제하는 데 적합하며 스크립트를 마우스 오른쪽 버튼으로 클릭하여 "Powershell로 실행"
#    -$ mcMaxExport> EVTX 당 내보낼 최대 이벤트, 빠른 샘플 / 스팟 확인을 위해 낮은 숫자로 설정.
#    -$ mcMaxImport> 최대 이벤트를 Excel로 가져 오면 스크립트가 현재 파일을 완료하고 다음 파일 가져 오기를 중지합니다. 가져 오는 동안 Excel에서 메모리 오류를 반환하는 경우 낮은 숫자로 설정합니다.
#    -$ mcStartTime> 'yyyy / MM / dd HH : mm'형식으로 내보낼 가장 이른 이벤트입니다. 여기서 HH 13은 오후 1시입니다 (예 : '2017/05/26 13:01'). 진행 상황을 필터링하는 데 사용합니다.  
#    -$ mcMaxThreads> 동시에 내보낼 evtx 파일의 최대 수. 4 기본값, 8로 설정하고 빠른 SSD HDD가 있는지 실험하십시오.
#
# 스크립트 변수 블록, 필요에 맞게 수정 ---------------------------------------- -----------------------------
  $ mcScriptPrompts  =  $ True             # 스크립트 기본값, 비대화 형 입력 및 출력의 경우 $ false.
  $ mcMaxExport  =  50000                 # 50000 각 EVTX 당 내보낼 최대 이벤트, Excel 메모리 오류가 발생하는 경우 수정합니다 (또는 샘플에 대해 처음 몇 evt 만 필요함).
  $ mcMaxImport  =  50000                 # 50000 개의 최대 이벤트를 Excel로 가져올 수 있습니다. ## 참고 ## : 최대 값을 초과하면 스크립트는 현재 가져 오기 파일을 완료하고 향후 가져 오기를 중지합니다.
  $ mcStartTime  =  ' 2020/05/26 11:06 '    # 'yyyy / MM / dd HH : mm'형식으로 내보낼 최초 582 * 이벤트 (여기서 HH 13은 오후 1시입니다. 예 : '2020/05/26) 11:06 '은 05/26 11:06부터 시작하는 이벤트를 나열합니다.이를 사용하여 새 이벤트를 필터링합니다.
  $ mcMaxThreads  =  4                    # CSV 내보내기 스레드 (작업)에 대한 최대 동시 Evt

# 내부 값 초기화, 수정하지 않음 ------------------------------------------ -------------------------------------------
  $ mcCSVImport  =  $ true
  $ mcEvtPath  =  $ null
  $ mcStartTime = [ datetime ] :: ParseExact ( $ mcStartTime , ' yyyy / MM / dd HH : mm ' , $ null )   # 문자열을 타임 스탬프로 변환
  $ mcProgressBarDelay  =  0 			 # 각 ProgressBar 업데이트 후 지연 시간 (초)

# ---- 기능 --------------------------
Function  mcSetPivotField ( $ mcPivotFieldSetting ) { # MSDN에 따라 피벗 필드 속성 설정 https://msdn.microsoft.com/en-us/library/office/ff820762.aspx
  if ( $ mcPivotFieldSetting [ 1 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .Orientation   =  $ mcPivotFieldSetting [ 1 ]} # 1 Orientation {$ xlRowField | $ xlDataField | $ xlColumnField}, XlPivotFieldOrientation
  if ( $ mcPivotFieldSetting [ 2 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .NumberFormat =  $ mcPivotFieldSetting [ 2 ]} # 2 NumberFormat {$ mcNumberF | $ mcPercentF}
  if ( $ mcPivotFieldSetting [ 3 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .Function      =  $ mcPivotFieldSetting [ 3 ]} # 3 Function {$ xlAverage | $ xlSum | $ xlCount}, XlConsolidationFunction에서
  if ( $ mcPivotFieldSetting [ 4 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .Calculation   =  $ mcPivotFieldSetting [ 4 ]} # 4 계산 {$ xlPercentOfTotal | $ xlPercentRunningTotal}, XlPivotFieldCalculation에서
  if ( $ mcPivotFieldSetting [ 5 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .BaseField     =  $ mcPivotFieldSetting [ 5 ]} # 5 BaseField <String>
  if ( $ mcPivotFieldSetting [ 6 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .Name          =  $ mcPivotFieldSetting [ 6 ]} # 6 이름 <문자열>
  if ( $ mcPivotFieldSetting [ 7 ] -ne  $ null ) { $ mcPivotFieldSetting [ 0 ] .Position      =  $ mcPivotFieldSetting [ 7 ]} # 7 위치
}

Function  mcSetPivotTableFormat ( $ mcPivotTable ) { # 피벗 테이블 코스메틱 및 시트 이름 설정     
  $ mcPT = $ mcPivotTable [ 0 ] .PivotTables ( $ mcPivotTable [ 1 ])
    $ mcPT .HasAutoFormat  =  $ False  # 2. AutoColumnWidth의 회전
  for ( $ i = 2 ; $ i  -lt  9 ; $ i ++ ) { # 3. SetColumnWidth for Sheet ($ mcPivotTable [0]), PivotTable ($ mcPivotTable [1]), Column ($ mcPivotTable [2-8 ])
    if ( $ mcPivotTable [ $ i ] -ne  $ null ) { $ mcPivotTable [ 0 ] .columns.item (( $ i - 1 )). columnWidth =  $ mcPivotTable [ $ i ]}
  }
  $ mcPivotTable [ 0 ] .Application.ActiveWindow.SplitRow =  3
  $ mcPivotTable [ 0 ] .Application.ActiveWindow.SplitColumn =  2
  $ mcPivotTable [ 0 ] .Application.ActiveWindow.FreezePanes =  $ true  # 1. R1C1 고정
  $ mcPivotTable [ 0 ] .Cells.Item ( 1 , 1 ) = " 필터 "
  $ mcPivotTable [ 0 ] .Cells.Item ( 3 , 1 ) = $ mcPivotTable [ 9 ] # 4 PivotTableName $ mcPivotTable [9]을 사용하여 R3C1에서 TXT를 설정합니다.
  $ mcPivotTable [ 0 ] .Name = $ mcPivotTable [ 10 ] # 5 시트 이름을 $ mcPivotTable [10]로 설정
    $ mcRC  = ( $ mcPivotTable [ 0 ] .UsedRange.Cells) .Rows.Count - 1
  if ( $ mcPivotTable [ 11 ] -ne  $ null ) { # $ mcPivotTable [11] ColorScale 설정
    $ mColorScaleRange = ' $ ' + $ mcPivotTable [ 11 ] + ' $ 4 : $ ' + $ mcPivotTable [ 11 ] + ' $ ' + $ mcRC        
    [ Void ] $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.AddColorScale ( 3 ) # $ mcPivotTable [11] = ColorScale
    $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.item ( 1 ) .ColorScaleCriteria.item ( 1 ) .type =  1  # xlConditionValueLowestValue
    $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.item ( 1 ) .ColorScaleCriteria.item ( 1 ) .FormatColor.Color =  8109667
    $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.item ( 1 ) .ColorScaleCriteria.item ( 2 ) .FormatColor.Color =  8711167
    $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.item ( 1 ) .ColorScaleCriteria.item ( 3 ) .type =  2  # xlConditionValueHighestValue
    $ mcPivotTable [ 0 ] .Range ( $ mColorScaleRange ) .FormatConditions.item ( 1 ) .ColorScaleCriteria.item ( 3 ) .FormatColor.Color =  7039480
  }
  if ( $ mcPivotTable [ 12 ] -ne  $ null ) { # $ mcPivotTable [12] Set DataBar
    $ mcDataBarRange = ' $ ' + $ mcPivotTable [ 12 ] + ' $ 4 : $ ' + $ mcPivotTable [ 12 ] + ' $ ' + $ mcRC  
    [ void ] $ mcPivotTable [ 0 ] .Range ( $ mcDataBarRange ) .FormatConditions.AddDatabar () # $ mcPivotTable [12] : Set DataBar
  }
}

Function  mcSortPivotFields ( $ mcPF ) { # $ mcPF를 기준으로 정렬하고 나중에 피벗 필드를 축소합니다.
  for ( $ i = 2 ; $ i  -lt  5 ; $ i ++ ) { # 나중에 피벗 필드 축소
    if ( $ mcPF [ $ i ] -ne  $ null ) {
      $ mcPF [ $ i ] .showDetail =  $ false 
    }
  }
  [ void ] ( $ mcPF [ 0 ] .Cells.Item ( 4 ,  2 )). sort (( $ mcPF [ 0 ] .Cells.Item ( 4 ,  2 )) ,  2 )
    [ void ] ( $ mcPF [ 0 ] .Cells.Item ( 4 ,  1 )). sort (( $ mcPF [ 0 ] .Cells.Item ( 4 ,  1 )) ,  1 )
}

Function  mcSetPivotTableHeaderColor ( $ mcSheet ) { # 쉽게 읽을 수 있도록 PiviotTable 헤더 색상 설정
  for ( $ i = 1 ; $ i  -lt  5 ; $ i ++ ) { # 헤더 색상 설정
    if ( $ mcSheet [ $ i ] -ne  $ null ) { $ mcSheet [ 0 ] .Range (( $ mcSheet [ $ i ] + " 3 " )). interior.Colorindex =  37 }          
  }
}

# ---- 메인 ---------
# ---- 스크립트 정보 -------
$ mcScriptPath  =  Split-Path (( Get-Variable MyInvocation - Scope 0 ) .Value) .MyCommand.Path
  if ( $ mcScriptPrompts ) {   # 대화 형 mcScriptPrompts
    $ mcEvtPath  =  Read-Host  " 저장된 시스템 evtx 또는 이전에 생성 된 582-*. csv에 대한 로컬, 매핑 또는 UNC 경로를 입력합니다. 후행 공백을 제거해야합니다. 예 : (c : \ EventData) `n 또는 경우 [Enter]를 누릅니다. 스크립트는 evtx 또는 CSV와 같은 파일 폴더에 있습니다. 'N ' 
    if ( $ mcEvtPath  -eq  ' ' ) { # 경로를 입력하지 않으면 스크립트 경로와 동일한 파일 폴더를 사용합니다.
      $ mcEvtPath =  $ mcScriptPath
      Write-Output  " 경로를 입력하지 않았습니다. 기본값은 "  $ mcEvtPath입니다.
    }
  } else {
    $ mcEvtPath =  $ mcScriptPath  # 비대화 형 스크립트는 이벤트 경로에 스크립트 경로를 사용합니다.    
  }
# ---- evtx를 CSV로 내보내기 ----------------------------------------- ----------
Write-Output  ' evtx를 csv로 변환합니다. '
  $ mcFiles  =  GET-ChildItem을  - 경로 $ mcEvtPath  |   여기서  { $ _ .name  -clike  ' * .evtx ' }
  ForEach ( $ mcFiles  의  $ mcFile ) { # * .evtx를 통한 루프
    $ mcFile  |  - 회원 추가  - MemberType NoteProperty - 이름 오며 MaxEvents - 힘 - 가치 $ mcMaxExport을
    $ mcFile  |  - 회원 추가  - MemberType NoteProperty - 이름 상영 - 힘 - 가치 $ mcStartTime을
# 작업 [ # 작업 시작 코드 1
    시작 - 작업  - ArgumentList의 ( , $ mcFile ) - 은 ScriptBlock { # 시작 - 작업 각각의 파일을 읽기위한
      매개 변수 ( $ mcFile )
# 직업]         
      쓰기-출력  " 읽기 $ mcFile "
      $ mc582s  =  Get-WinEvent  - FilterHashtable @ { 경로 = $ mcfile .FullName ; LogName = " 시스템 " ; 레벨 = 3 , 4 ; StartTime = $ mcFile .StartTime ; ID = 5827 , 5828 , 5829 , 5830 , 5831 } - 오며 MaxEvents $ mcFile의 .MaxEvents  - ErrorAction이 SilentlyContinue
      If ( $ mc582s  -ne  $ null ) {
        $ mcOutFile  =  $ mcFile .DirectoryName + ' \ 582- ' + $ mcFile .Name + ' .csv '
        쓰기-출력  " 이벤트 5826-28이 발견되어 $ mcOutFile "을 생성합니다. 
        $ mc582sOut  =  @ () # CSV 항목을 내보내기위한 배열
        ForEach ( $ mc582s  에서  $ mc582 ) {
            $ mcObject  =  새 개체 System.Object
				$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 EventSource를 - 힘 - 값 $ mc582 .MachineName
				$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 EVENTTIME - 힘 - 가치 $의 mc582을 .TimeCreated
				$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 이벤트 ID - 힘 - 가치 $의 mc582을 .ID
				스위치 ( $ mc582 .ID ) {
					5827 { # Denided Unsecure RPC machine client
						$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 NRPCType - 힘 - 값 ' - : 5827,5828이 거부 안전하지 않은 NRPC EVT를 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 이름 - 힘 - 값 $ mc582 .properties의 [ 0 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 도메인 이름을 - 힘 - 값 $ mc582 .properties의 [ 1 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 ACCOUNTTYPE을 - 힘 - 값 $ mc582 .properties의 [ 2 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOS을 - 힘 - 값 $ mc582 .properties의 [ 3 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsBuild을 - 힘 - 값 $ mc582 .properties의 [ 4 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsServicePack을 - 힘 - 값 $ mc582 .properties의 [ 5 ] .value
						}
					5829 { # 임시 허용 된 비보안 RPC 시스템 클라이언트
						$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 NRPCType - 힘 - 값 ' - : 5829 1 TempAllowed 보안을 해제 NRPC EVT를 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 이름 - 힘 - 값 $ mc582 .properties의 [ 0 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 도메인 이름을 - 힘 - 값 $ mc582 .properties의 [ 1 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 ACCOUNTTYPE을 - 힘 - 값 $ mc582 .properties의 [ 2 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOS을 - 힘 - 값 $ mc582 .properties의 [ 3 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsBuild을 - 힘 - 값 $ mc582 .properties의 [ 4 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsServicePack을 - 힘 - 값 $ mc582 .properties의 [ 5 ] .value
						}
					5830 { # 허용 된 비보안 RPC 시스템 클라이언트
						$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 NRPCType - 힘 - 값 ' - : 5830,5831 3 허용 비보안 NRPC EVT를 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 이름 - 힘 - 값 $ mc582 .properties의 [ 0 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 도메인 이름을 - 힘 - 값 $ mc582 .properties의 [ 1 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 ACCOUNTTYPE을 - 힘 - 값 $ mc582 .properties의 [ 2 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOS을 - 힘 - 값 $ mc582 .properties의 [ 3 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsBuild을 - 힘 - 값 $ mc582 .properties의 [ 4 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsServicePack을 - 힘 - 값 $ mc582 .properties의 [ 5 ] .value
						}						
					5828 { # 임시 허용 비보안 RPC 신뢰
						$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 NRPCType - 힘 - 값 ' - : 5827,5828이 거부 안전하지 않은 NRPC EVT를 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 이름 - 힘 - 값 $ mc582 .properties의 [ 1 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 도메인 이름을 - 힘 - 값 $ mc582 .properties의 [ 2 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 ACCOUNTTYPE을 - 힘 - 값 $ mc582 .properties의 [ 0 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOS을 - 힘 - 값 ' 도메인 트러스트 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsBuild을 - 힘 - 값 ' N / A '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsServicePack을 - 힘 - 값 ' N / A '
						}
					5831 { # 비보안 RPC 신뢰 허용
						$ mcObject  |  - 회원 추가  - MemberType NoteProperty - 이름 NRPCType - 힘 - 값 ' - : 5830,5831 3 허용 비보안 NRPC EVT를 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 이름 - 힘 - 값 $ mc582 .properties의 [ 1 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 도메인 이름을 - 힘 - 값 $ mc582 .properties의 [ 2 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 ACCOUNTTYPE을 - 힘 - 값 $ mc582 .properties의 [ 0 ] .value
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOS을 - 힘 - 값 ' 도메인 트러스트 '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsBuild을 - 힘 - 값 ' N / A '
						$ mcObject  |  추가 - 회원  - MemberType NoteProperty - 이름 MachineOsServicePack을 - 힘 - 값 ' N / A '
						}
				}
                $ mcObject .Name  =  $ mcObject .Name.Trim ()
                $ mcObject .DomainName  =  $ mcObject .DomainName.Trim ()
                $ mcObject .AccountType  =  $ mcObject .AccountType.Trim ()
                $ mcObject .MachineOS  =  $ mcObject .MachineOS.Trim ()
                $ mcObject .MachineOsBuild  =  $ mcObject .MachineOsBuild.Trim ()
                $ mcObject .MachineOsServicePack  =  $ mcObject .MachineOsServicePack.Trim ()
                  $ mc582sOut  + =  $ mcObject
        }
        $ mc582sout  |  ConvertTo-Csv  - NoTypeInformation |  외부 파일  $ mcOutFile
      } 
# Job [# Maxthread 코드 2/3      
    } |  Out-Null  # 작업 출력
      쓰기-출력  "    처리 : $ mcFile " 
      While (( Get-Job  - State ' Running ' ) .Count -ge  $ mcMaxThreads ) { Start-Sleep  - Milliseconds 10 } # 일시 중지, $ mcMaxThreads 작업 수만 실행합니다.
# 직업]
  }
# 작업 [# 작업 정리 코드 3/3
    While (( Get-Job  - State ' Running ' ) .Count -gt  0 ) {
        쓰기 - 진행  - 활동 " 내보내기 evtx "  - PERCENTCOMPLETE ((( $ mcfiles .Count - ( GET-작업  - 주 ' 실행 ' ) .Count) / $ mcfiles .Count ) * 100 )
        시작-수면  - 밀리 초 10 
    } # 마지막 작업이 완료 될 때까지 기다립니다.
    # Get-Job | 작업 받기
    - 작업하기  - 국가가 완료 |  작업 제거 
# 직업]
# ---- Excel로 CSV 가져 오기 ----------------------------------------- ------------
  if ( $ mcCSVImport  -eq  $ true ) { # 디버그 전용, CSV를 Excel로 가져 오기
    $ mcFiles  =  GET-ChildItem을  - 경로 $ mcEvtPath  |  여기서 { $ _ .name  -clike  ' 582- *. csv ' }
    If ( $ mcFiles  -ne  $ null ) { # 디렉토리에 CSV가 있으면 새 Excel 통합 문서를 만듭니다.
      cd $ mcEvtPath  # Import-Csv가 모든 파일을 읽습니다.
      $ mcObject  =  가져 오기-CSV  $의 mcfiles  - 구분자 ' , '
      cd $ mcScriptPath  # 스크립트 경로로 돌아 가기
      # 쓰기 출력 'Import csv to excel.'
        $ mcExcel  =  New-Object  - ComObject excel.application
        $ mcWorkbooks  =  $ mcExcel .Workbooks.Add ()
        $ Sheet1  =  $ mcWorkbooks .worksheets.Item ( 1 )
          $ mcCurrentRow  =  $ mcFileProcessed  =  1
      ForEach ( $ mcFiles  의  $ mcFile ) { # Excel TXT 커넥터 정의 및 가져 오기 / 추가
        쓰기 - 진행  - 활동 " 가져 오기 $ mcFile "  - PERCENTCOMPLETE (( $ mcFileProcessed / $ mcfiles .Count ) * 100 )
$ mcProgressBarDelay            수면
           $ mcFileProcessed = $ mcFileProcessed + 1
        if ( $ mcCurrentRow  -le  $ mcMaxImport ) { # 최대 $ mcMaxImport 수의 레코드 만 가져옵니다.
          $ mcConnector  =  $ Sheet1 .QueryTables.add (( " TEXT; "  +  $ mcEvtPath + ' \ ' + $ mcFile ) , $ Sheet1 .Range (( ' a ' + ( $ mcCurrentRow )))))
          $ Sheet1 .QueryTables.item ( $ mcConnector .name ) .TextFileCommaDelimiter =  $ True
          $ Sheet1 .QueryTables.item ( $ mcConnector .name ) .TextFileParseType   =  1
          [ void ] $ Sheet1 .QueryTables.item ( $ mcConnector .name ) .Refresh ()
            if ( $ mcCurrentRow  -ne  1 ) {[ void ] ( $ Sheet1 .Cells.Item ( $ mcCurrentRow , 1 ) .entireRow) .delete ()} # 두 번째 및 이후 CSV에서 헤더를 삭제합니다.
            $ mcCurrentRow  =  $ Sheet1 .UsedRange.EntireRow.Count + 1
        } else {
          쓰기 출력  "     *** 최대 [ $ mcMaxImport ] 가져 오기 이벤트에 도달했습니다. 건너 뛰는 중 : $ mcfile "
        }
      }
# ---- XLS, Excel 전역 사용자 지정 ---------------------------------------- ----------------   
    # 쓰기 출력 'Customizing XLS.' #https : //msdn.microsoft.com/en-us/library/bb241425 (v = office.12) .aspx, https://msdn.microsoft.com/en-us/library/office/ff838592.aspx   
      $ xlRowField  =  1  # XlPivotFieldOrientation
      $ xlPageField  =  3  # XlPivotFieldOrientation
      $ xlDataField  =  4  # XlPivotFieldOrientation
      $ xlColumnField  =  2  # XlPivotFieldOrientation
      $ xlAverage  =  -4106  # XlConsolidationFunction
      $ xlSum  =  -4157  # XlConsolidationFunction
      $ xlCount  =  -4112  # XlConsolidationFunction
      $ xlPercentOfTotal  =  8  # XlPivotFieldCalculation
      $ xlPercentRunningTotal  =  13  # XlPivotFieldCalculation
      $ mcNumberF  =  " ###, ###, ###, ###, ### "
      $ mcPercentF  =  " # 0.00 % "
      $ mcDateF  =  " yyyy / m / dh : mm "
      $ mcDateGroupFlags = ( $ false ,  $ false ,  $ true ,  $ true ,  $ true ,  $ false ,  $ false ) # 월, 일, 시간, https://msdn.microsoft.com/en-us/library/office/ ff839808.aspx
  # ------- # Sheet1-RawData -------------------------------------- -------------------------
        $ Sheet1 .Range ( " A1 " ) .Autofilter () |  Out-Null
        $ Sheet1 .Application.ActiveWindow.SplitRow  =  1
        $ Sheet1 .Application.ActiveWindow.FreezePanes  =  $ true
          # 쓰기 출력 '탭 0.5826, 5827, 5828 이벤트 가져 오기'
          쓰기 - 진행  - 활동 " 0.Raw RPC 이벤트 탭 작성 "  - PERCENTCOMPLETE (30)  
$ mcProgressBarDelay             수면  
  # ------- # 시트 2-피벗 테이블 1 -------------------------------------- -------------------------
        $ Sheet2  =  $ mcWorkbooks .Worksheets.add ()
        $ PivotTable1  =  $ mcWorkbooks .PivotCaches () .Create ( 1 , " Sheet1! R1C1 : R $ ( $ Sheet1 .UsedRange.Rows.count ) C $ ( $ Sheet1 .UsedRange.Columns.count ) " , 5 ) # xlDatabase = 1 xlPivotTableVersion15 = 5 Excel2013
        $ PivotTable1 .CreatePivotTable ( " Sheet2! R1C1 " ) |  Out-Null
          $ mcPF00  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " EventSource " )
          mcSetPivotField ( $ mcPF00 ,  $ xlPageField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF0  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " NRPCType " )
            mcSetPivotField ( $ mcPF0 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF1  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " MachineOS " )
            mcSetPivotField ( $ mcPF1 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF2  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " DomainName " )
            mcSetPivotField ( $ mcPF2 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF3  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " Name " )
            mcSetPivotField ( $ mcPF3 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF  =  $ Sheet2 .PivotTables ( " PivotTable1 " ) .PivotFields ( " EventTime " )
            mcSetPivotField ( $ mcPF ,  $ xlDataField ,  $ mcNumberF ,  $ null ,  $ null ,  $ null ,  " 이벤트 수 " , 1 )
        mcSetPivotTableFormat ( $ Sheet2 ,  " PivotTable1 " ,  60 ,  15 ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null , " NRPC Type " ,  " 1.OS, Domain, Client " ,  $ null ,  $ null )
        mcSortPivotFields ( $ sheet2 , $ mcPF , $ mcPF0 )
        mcSetPivotTableHeaderColor ( $ Sheet2 ,  " A " )
		$ Sheet2 .Cells.Item ( 1 , 1 ) .Formula = ' 소스 DC '
        # 쓰기 출력 'Tab 1. NRPCType-OS, Domain, Client Done'
        쓰기 - 진행  - 활동 " 탭 1.NRPCType-OS, 도메인, 클라이언트 피벗 테이블 작성 "  - PERCENTCOMPLETE (60) 
$ mcProgressBarDelay           수면
  # ------- # Sheet3-피벗 테이블 2 -------------------------------------- -------------------------
        $ Sheet3  =  $ mcWorkbooks .Worksheets.add ()
        $ PivotTable2  =  $ mcWorkbooks .PivotCaches () .Create ( 1 , " Sheet1! R1C1 : R $ ( $ Sheet1 .UsedRange.Rows.count ) C $ ( $ Sheet1 .UsedRange.Columns.count ) " , 5 ) # xlDatabase = 1 xlPivotTableVersion15 = 5 Excel2013
        $ PivotTable2 .CreatePivotTable ( " Sheet3! R1C1 " ) |  Out-Null
          $ mcPF00  =  $ Sheet3 .PivotTables ( " PivotTable2 " ) .PivotFields ( " EventSource " )
          mcSetPivotField ( $ mcPF00 ,  $ xlPageField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF0  =  $ Sheet3 .PivotTables ( " PivotTable2 " ) .PivotFields ( " NRPCType " )
            mcSetPivotField ( $ mcPF0 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF1  =  $ Sheet3 .PivotTables ( " PivotTable2 " ) .PivotFields ( " DomainName " )
            mcSetPivotField ( $ mcPF1 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF2  =  $ Sheet3 .PivotTables ( " PivotTable2 " ) .PivotFields ( " Name " )
            mcSetPivotField ( $ mcPF2 ,  $ xlRowField ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null )
          $ mcPF  =  $ Sheet3 .PivotTables ( " PivotTable2 " ) .PivotFields ( " EventTime " )
            mcSetPivotField ( $ mcPF ,  $ xlDataField ,  $ mcNumberF ,  $ null ,  $ null ,  $ null ,  " 이벤트 수 " , 1 )
        mcSetPivotTableFormat ( $ Sheet3 ,  " PivotTable2 " ,  60 ,  15 ,  $ null ,  $ null ,  $ null ,  $ null ,  $ null , " NRPC Type " ,  " 2.Domain, Client " ,  $ null ,  $ null )
        mcSortPivotFields ( $ Sheet3 , $ mcPF , $ mcPF0 )
        mcSetPivotTableHeaderColor ( $ Sheet3 ,  " A " )
		$ Sheet3 .Cells.Item ( 1 , 1 ) .Formula = ' 소스 DC '
        # Write-Output '탭 2. NRPCType-Domain, Client Done'
        쓰기 - 진행  - 활동 " 탭 2.NRPCType 도메인, 클라이언트 피벗 테이블 작성 "  - PERCENTCOMPLETE 90 
$ mcProgressBarDelay           수면
  # ------- # $ Sheet4-$ PivotTable3 ------------------------------------ ---------------------------
        $ Sheet4  =  $ mcWorkbooks .Worksheets.add ()
        $ PivotTable3  =  $ mcWorkbooks .PivotCaches () .Create ( 1 , " Sheet1! R1C1 : R $ ( $ Sheet1 .UsedRange.Rows.count ) C $ ( $ Sheet1 .UsedRange.Columns.count ) " , 5 ) # xlDatabase = 1 xlPivotTableVersion15 = 5 Excel2013
        $ PivotTable3 .CreatePivotTable ( " Sheet4! R1C1 " ) |  Out-Null
        $ Sheet4 .name  =  " 3.CustomPivot "       
      # 정렬 시트 이름을 반대로 설정
      $ Sheet1 .Name  =  " 0.Raw RPC 이벤트 "
      $ Sheet2 .Tab.ColorIndex  =  $ Sheet3 .Tab.ColorIndex  = 35
      $ mcWorkSheetNames  =  New-Object System.Collections.ArrayList
        foreach는 ( $ mcWorkSheet  에서  $ mcWorkbooks .Worksheets ) { $ mcWorkSheetNames .add ( $ mcWorkSheet .NAME를 ) |  Out-null }
        $ mctmp  =  $ mcWorkSheetNames .Sort () |  Out-Null
        대한 ( $ 전 = 0 ; $ 내가  -lt  $ mcWorkSheetNames .Count - 1 ; $ 내가 ++ ) { #의 정렬 이름입니다.
          $ mcTmp  =  $ mcWorkSheetNames [ $ i ]
          $ mcBefore  =  $ mcWorkbooks .Worksheets.Item ( $ mcTmp )
          $ mcAfter  =  $ mcWorkbooks .Worksheets.Item ( $ i + 1 )
          $ mcBefore .Move ( $ mcAfter )
        }
        $ Sheet1. 활성화 ()
        쓰기 - 진행  - 활동 " 엑셀 시트 만들기 "  - PERCENTCOMPLETE (100)
$ mcProgressBarDelay           수면
        if ( $ mcScriptPrompts ) { # SaveAsFile
          $ mcFileName  =  읽기 호스트  " 추출 된 이벤트 582 XLSX을 저장할 파일 이름을 입력합니다. 'N '
          if ( $ mcFileName ) {
            Write-Output  " $ mcEvtPath \ $ mcFileName .xlsx에 파일 저장 중 "
            $ mcWorkbooks .SaveAs ( $ mcEvtPath + ' \ ' + $ mcFileName )
          }
          $ mcCleanup  =  Read-Host  " Delete 582- *. CSV? ([Enter] / [Y] 삭제, [N] 유지 csv) `n "
          if ( $ mcCleanup  -ne  ' N ' ) {
            은 Get-ChildItem을이  - 경로 mcEvtPath을 $  |  여기서 { $ _ .name  -clike  ' 582- *. csv ' } |  foreach ( $ _ ) {
              항목 제거  $ mcEvtPath ' \ ' $ _
              쓰기 출력  "     $ _ 삭제됨. "
            }
          }
        }
        $ mcExcel .visible  =  $ true 
    } else { # mcFiles의 끝
      Write-Output  "     지정된 $ mcEvtPath에 582- *. csv가 없습니다 . "
    }
  }
Write-Output  ' 스크립트가 완료되었습니다. '
